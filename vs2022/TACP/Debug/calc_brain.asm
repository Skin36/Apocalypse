; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31933.0 

	TITLE	D:\FreeApoc\Apocalypse\vs2022\TACP\Debug\calc_brain.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_section_array
PUBLIC	_brain_index_count
_DATA	SEGMENT
COMM	_brain_instance:BYTE:087b7cH
_DATA	ENDS
_BSS	SEGMENT
_section_array DD 096H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_brain_ptr:DWORD
_DATA	ENDS
_BSS	SEGMENT
_brain_index_count DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_fd:DWORD
COMM	_BRAIN_DAT:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__CD417A16_concurrencysal@h DB 01H
__18C11F8D_sal@h DB 01H
__BD42D05E_vadefs@h DB 01H
__2DC9DF70_vcruntime@h DB 01H
__6569C2CA_corecrt@h DB 01H
__AC4A4048_fcntl@h DB 01H
__A9063C41_corecrt_share@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__2671BD82_corecrt_io@h DB 01H
__9B190114_io@h DB 01H
__64F617E8_types@h DB 01H
__1DC1E279_stat@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__6C20D4D3_corecrt_malloc@h DB 01H
__C9393812_stddef@h DB 01H
__D493B9BD_corecrt_search@h DB 01H
__1473E23E_corecrt_wstdlib@h DB 01H
__7B399007_limits@h DB 01H
__B49664B7_stdlib@h DB 01H
__CDDAF8CA_errno@h DB 01H
__6BB4896E_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__C54FBE38_stdint@h DB 01H
__741AE07E_corecrt_math@h DB 01H
__91D68F2D_math@h DB 01H
__0DAB258A_calc_brain@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_load_brain
PUBLIC	_save_brain
PUBLIC	_find_row_brain_dat
PUBLIC	_fill_brain
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BC@DDIBPEID@TACDATA?1BRAIN?4DAT@		; `string'
PUBLIC	??_C@_0BF@CEHMMOFM@TACDATA?1EXPERIEN?4DAT@	; `string'
PUBLIC	??_C@_0BD@BPFPGIEP@Cannot?5open?5file?4?6@	; `string'
PUBLIC	??_C@_0CH@KOJDAIDB@EXPERIEN?5section?5less?5then?5114?5@ ; `string'
PUBLIC	??_C@_0BB@LCJJCINC@tmp_sec_num?5?$CFd?5?6@	; `string'
PUBLIC	??_C@_09LPDGMMCG@v115?5?$CFf?5?6@		; `string'
PUBLIC	??_C@_0BD@CAPAPHJL@TACDATA?1BRAIN2?4DAT@	; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0CB@KBMNMHCO@Error?5occured?5while?5opening?5fil@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	__real@3f3a36e2eb1c432d
PUBLIC	__real@3f800000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@41200000
PUBLIC	__real@501502f9
PUBLIC	__real@bf000000
PUBLIC	__real@d09502f9
EXTRN	__imp___open:PROC
EXTRN	__imp__lseek:PROC
EXTRN	__imp__read:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__getc:PROC
EXTRN	__imp__perror:PROC
EXTRN	__imp__putc:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	_memset:PROC
EXTRN	_exp:PROC
EXTRN	__imp__floor:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __real@d09502f9
CONST	SEGMENT
__real@d09502f9 DD 0d09502f9r			; -2e+10
CONST	ENDS
;	COMDAT __real@bf000000
CONST	SEGMENT
__real@bf000000 DD 0bf000000r			; -0.5
CONST	ENDS
;	COMDAT __real@501502f9
CONST	SEGMENT
__real@501502f9 DD 0501502f9r			; 1e+10
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f3a36e2eb1c432d
CONST	SEGMENT
__real@3f3a36e2eb1c432d DQ 03f3a36e2eb1c432dr	; 0.0004
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KBMNMHCO@Error?5occured?5while?5opening?5fil@
CONST	SEGMENT
??_C@_0CB@KBMNMHCO@Error?5occured?5while?5opening?5fil@ DB 'Error occured'
	DB	' while opening file', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CAPAPHJL@TACDATA?1BRAIN2?4DAT@
CONST	SEGMENT
??_C@_0BD@CAPAPHJL@TACDATA?1BRAIN2?4DAT@ DB 'TACDATA/BRAIN2.DAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LPDGMMCG@v115?5?$CFf?5?6@
CONST	SEGMENT
??_C@_09LPDGMMCG@v115?5?$CFf?5?6@ DB 'v115 %f ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LCJJCINC@tmp_sec_num?5?$CFd?5?6@
CONST	SEGMENT
??_C@_0BB@LCJJCINC@tmp_sec_num?5?$CFd?5?6@ DB 'tmp_sec_num %d ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KOJDAIDB@EXPERIEN?5section?5less?5then?5114?5@
CONST	SEGMENT
??_C@_0CH@KOJDAIDB@EXPERIEN?5section?5less?5then?5114?5@ DB 'EXPERIEN sec'
	DB	'tion less then 114 bytes.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BPFPGIEP@Cannot?5open?5file?4?6@
CONST	SEGMENT
??_C@_0BD@BPFPGIEP@Cannot?5open?5file?4?6@ DB 'Cannot open file.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CEHMMOFM@TACDATA?1EXPERIEN?4DAT@
CONST	SEGMENT
??_C@_0BF@CEHMMOFM@TACDATA?1EXPERIEN?4DAT@ DB 'TACDATA/EXPERIEN.DAT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DDIBPEID@TACDATA?1BRAIN?4DAT@
CONST	SEGMENT
??_C@_0BC@DDIBPEID@TACDATA?1BRAIN?4DAT@ DB 'TACDATA/BRAIN.DAT', 00H ; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	0a22H
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\TACP\C_Sources\calc_brain.c
;	COMDAT _fill_brain
_TEXT	SEGMENT
_v46$ = -1516						; size = 4
_v115$ = -1504						; size = 4
_v47$ = -1492						; size = 4
_tmp_sec_num$ = -1480					; size = 4
_section_array_3$ = -1468				; size = 600
_temp_section$ = -860					; size = 4
_n$ = -848						; size = 4
_m$ = -836						; size = 4
_num$ = -824						; size = 4
_v20$1 = -812						; size = 4
_v21$2 = -800						; size = 4
_v27$ = -788						; size = 4
_v26$ = -776						; size = 4
_v110$ = -764						; size = 4
_v109$ = -752						; size = 4
_v105$ = -740						; size = 4
_v107$ = -728						; size = 4
_k$ = -716						; size = 4
_section_array_2$ = -704				; size = 600
_v11$3 = -96						; size = 4
_v14$4 = -84						; size = 4
_v9$ = -72						; size = 4
_brn_row$ = -60						; size = 4
_sec_temp_num$ = -48					; size = 4
_exs_ptr$ = -36						; size = 4
_file_exp$ = -24					; size = 4
_file_brain$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
_fill_brain PROC					; COMDAT

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2096				; 00000830H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1520]
	mov	ecx, 380				; 0000017cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __0DAB258A_calc_brain@c
	call	@__CheckForDebuggerJustMyCode@4

; 52   :     char* file_brain = "TACDATA/BRAIN.DAT";

	mov	DWORD PTR _file_brain$[ebp], OFFSET ??_C@_0BC@DDIBPEID@TACDATA?1BRAIN?4DAT@

; 53   :     char* file_exp = "TACDATA/EXPERIEN.DAT";

	mov	DWORD PTR _file_exp$[ebp], OFFSET ??_C@_0BF@CEHMMOFM@TACDATA?1EXPERIEN?4DAT@

; 54   : 
; 55   :     brain_ptr = (struct brain_struct*)malloc(25 * sizeof(struct brain_struct));

	mov	esi, esp
	push	555900					; 00087b7cH
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _brain_ptr, eax

; 56   :     memset(brain_ptr, 0, 555900);

	push	555900					; 00087b7cH
	push	0
	mov	eax, DWORD PTR _brain_ptr
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 57   :     struct experien_struct* exs_ptr = (struct experien_struct*)malloc(sizeof(struct experien_struct));

	mov	esi, esp
	push	114					; 00000072H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _exs_ptr$[ebp], eax

; 58   :     int sec_temp_num = 0;

	mov	DWORD PTR _sec_temp_num$[ebp], 0

; 59   :     int brn_row = 0;

	mov	DWORD PTR _brn_row$[ebp], 0

; 60   :     if ((fd = _open(file_exp, O_RDONLY | O_BINARY)) == -1) {

	mov	esi, esp
	push	32768					; 00008000H
	mov	eax, DWORD PTR _file_exp$[ebp]
	push	eax
	call	DWORD PTR __imp___open
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fd, eax
	cmp	DWORD PTR _fd, -1
	jne	SHORT $LN29@fill_brain

; 61   :         printf("Cannot open file.\n");

	push	OFFSET ??_C@_0BD@BPFPGIEP@Cannot?5open?5file?4?6@
	call	_printf
	add	esp, 4
$LN29@fill_brain:

; 62   :     }
; 63   : 
; 64   :     /* --------------------------------------PART 1 set default values-------------------------------------------------------- */
; 65   : 
; 66   : 
; 67   : 
; 68   : 
; 69   : 
; 70   :     int v9;
; 71   :     while (1)

	mov	eax, 1
	test	eax, eax
	je	$LN3@fill_brain

; 72   :     {
; 73   :         if ((read(fd, exs_ptr, 114)) != 114) {

	mov	esi, esp
	push	114					; 00000072H
	mov	eax, DWORD PTR _exs_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fd
	push	ecx
	call	DWORD PTR __imp__read
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 114				; 00000072H
	je	SHORT $LN30@fill_brain

; 74   :             printf("EXPERIEN section less then 114 bytes.\n");

	push	OFFSET ??_C@_0CH@KOJDAIDB@EXPERIEN?5section?5less?5then?5114?5@
	call	_printf
	add	esp, 4

; 75   :             break;

	jmp	$LN3@fill_brain
$LN30@fill_brain:

; 76   :         }
; 77   : 
; 78   :         //printf("index %5d row_count %5d section %5d \n",exs_ptr->index,exs_ptr->row_count,exs_ptr->section);
; 79   :         brn_row = find_row_brain_dat(exs_ptr->index, exs_ptr->row_count, exs_ptr->section);

	mov	eax, DWORD PTR _exs_ptr$[ebp]
	mov	ecx, DWORD PTR [eax+110]
	push	ecx
	mov	edx, DWORD PTR _exs_ptr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_find_row_brain_dat
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _brn_row$[ebp], eax

; 80   :         if (brn_row < 0)

	cmp	DWORD PTR _brn_row$[ebp], 0
	jge	SHORT $LN31@fill_brain

; 81   :             return -4;

	mov	eax, -4					; fffffffcH
	jmp	$LN1@fill_brain
$LN31@fill_brain:

; 82   : 
; 83   :         sec_temp_num++;

	mov	eax, DWORD PTR _sec_temp_num$[ebp]
	add	eax, 1
	mov	DWORD PTR _sec_temp_num$[ebp], eax

; 84   :         v9 = exs_ptr->section + 1;

	mov	eax, DWORD PTR _exs_ptr$[ebp]
	mov	ecx, DWORD PTR [eax+110]
	add	ecx, 1
	mov	DWORD PTR _v9$[ebp], ecx

; 85   :         if (v9 < (brain_ptr + brn_row)->section)

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _v9$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+8]
	jae	SHORT $LN32@fill_brain

; 86   :             v9 = (brain_ptr + brn_row)->section;

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _v9$[ebp], edx
$LN32@fill_brain:

; 87   :         (brain_ptr + brn_row)->section = v9;

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _v9$[ebp]
	mov	DWORD PTR [ecx+eax+8], edx

; 88   :         int v14 = 0;

	mov	DWORD PTR _v14$4[ebp], 0

; 89   :         int* v11 = &section_array[brn_row][exs_ptr->section];

	imul	eax, DWORD PTR _brn_row$[ebp], 24
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	mov	edx, DWORD PTR [ecx+110]
	lea	eax, DWORD PTR _section_array[eax+edx*4]
	mov	DWORD PTR _v11$3[ebp], eax

; 90   : 
; 91   :         //printf("index %5d row_count %5d section %5d \n",(brain_ptr + brn_row)->index,(brain_ptr + brn_row)->row_count,(brain_ptr + brn_row)->section);
; 92   :         if (!*v11)

	mov	eax, DWORD PTR _v11$3[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN5@fill_brain

; 93   :         {
; 94   :             if ((brain_ptr + brn_row)->row_count > 0)

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	cmp	DWORD PTR [ecx+eax+4], 0
	jbe	$LN5@fill_brain
$LN6@fill_brain:

; 95   :             {
; 96   :                 do
; 97   :                 {
; 98   :                     (brain_ptr + brn_row)->fsection[exs_ptr->section].shot_section[v14][0] = 10000000000.0;

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	add	eax, DWORD PTR _brain_ptr
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	imul	edx, DWORD PTR [ecx+110], 3704
	lea	eax, DWORD PTR [eax+edx+12]
	imul	ecx, DWORD PTR _v14$4[ebp], 48
	add	eax, ecx
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR __real@501502f9
	movss	DWORD PTR [eax+ecx], xmm0

; 99   :                     (brain_ptr + brn_row)->fsection[exs_ptr->section].shot_section[v14][1] = -20000000000.0;

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	add	eax, DWORD PTR _brain_ptr
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	imul	edx, DWORD PTR [ecx+110], 3704
	lea	eax, DWORD PTR [eax+edx+12]
	imul	ecx, DWORD PTR _v14$4[ebp], 48
	add	eax, ecx
	mov	edx, 4
	shl	edx, 0
	movss	xmm0, DWORD PTR __real@d09502f9
	movss	DWORD PTR [eax+edx], xmm0

; 100  :                     ++v14;

	mov	eax, DWORD PTR _v14$4[ebp]
	add	eax, 1
	mov	DWORD PTR _v14$4[ebp], eax

; 101  :                 } while (v14 < (brain_ptr + brn_row)->row_count);

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _v14$4[ebp]
	cmp	edx, DWORD PTR [ecx+eax+4]
	jb	$LN6@fill_brain
$LN5@fill_brain:

; 102  :             }
; 103  :         }
; 104  :         ++* v11;

	mov	eax, DWORD PTR _v11$3[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _v11$3[ebp]
	mov	DWORD PTR [edx], ecx

; 105  :     }

	jmp	$LN29@fill_brain
$LN3@fill_brain:

; 106  : 
; 107  : 
; 108  :         /*
; 109  :         int k1;
; 110  :         int n1;
; 111  :         for (k1 = 0; k1<25; k1++)
; 112  :         {
; 113  : 
; 114  :             for (n1 = 0; n1<6; n1++)
; 115  :           {
; 116  :             printf("index %5d section %5d count %5d \n",(brain_ptr + k1)->index,(brain_ptr + k1)->section,section_array[k1][n1]);
; 117  :           }
; 118  :         }
; 119  :         
; 120  : 
; 121  :     save_brain("TACDATA/BRAIN2.DAT", brain_ptr);
; 122  :     free(brain_ptr);
; 123  :     free(exs_ptr);
; 124  :     return 0;
; 125  : 
; 126  : */
; 127  : 
; 128  : 
; 129  : /* --------------------------------------PART 2  find min/max--------------------------------------------------------------- */
; 130  :     int section_array_2[25][6] = { 0 };

	push	600					; 00000258H
	push	0
	lea	eax, DWORD PTR _section_array_2$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 131  : 
; 132  : 
; 133  : 
; 134  : 
; 135  : 
; 136  :     if (lseek(fd, 0, 0))

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _fd
	push	eax
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN35@fill_brain

; 137  :         return -3;

	mov	eax, -3					; fffffffdH
	jmp	$LN1@fill_brain
$LN35@fill_brain:

; 138  : 
; 139  :     int k;
; 140  :     float v107;
; 141  :     float v105;
; 142  :     float v109;
; 143  :     float v110;
; 144  :     float v26;
; 145  :     float v27;
; 146  :     while (1)

	mov	eax, 1
	test	eax, eax
	je	$LN8@fill_brain

; 147  :     {
; 148  :         if ((read(fd, exs_ptr, 114)) != 114)

	mov	esi, esp
	push	114					; 00000072H
	mov	eax, DWORD PTR _exs_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fd
	push	ecx
	call	DWORD PTR __imp__read
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 114				; 00000072H
	je	SHORT $LN36@fill_brain

; 149  :         {
; 150  :             printf("EXPERIEN section less then 114 bytes.\n");

	push	OFFSET ??_C@_0CH@KOJDAIDB@EXPERIEN?5section?5less?5then?5114?5@
	call	_printf
	add	esp, 4

; 151  :             break;

	jmp	$LN8@fill_brain
$LN36@fill_brain:

; 152  :         }
; 153  :         brn_row = find_row_brain_dat(exs_ptr->index, exs_ptr->row_count, exs_ptr->section);

	mov	eax, DWORD PTR _exs_ptr$[ebp]
	mov	ecx, DWORD PTR [eax+110]
	push	ecx
	mov	edx, DWORD PTR _exs_ptr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_find_row_brain_dat
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _brn_row$[ebp], eax

; 154  :         int* v21 = &section_array[brn_row][exs_ptr->section];

	imul	eax, DWORD PTR _brn_row$[ebp], 24
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	mov	edx, DWORD PTR [ecx+110]
	lea	eax, DWORD PTR _section_array[eax+edx*4]
	mov	DWORD PTR _v21$2[ebp], eax

; 155  :         int* v20 = &section_array_2[brn_row][exs_ptr->section];

	imul	eax, DWORD PTR _brn_row$[ebp], 24
	lea	ecx, DWORD PTR _section_array_2$[ebp+eax]
	mov	edx, DWORD PTR _exs_ptr$[ebp]
	mov	eax, DWORD PTR [edx+110]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _v20$1[ebp], ecx

; 156  : 
; 157  :         if (*v21 < 100 || 100 * (*v21 / 100) > *v20 && !(*v20 % (*v21 / 100)))

	mov	eax, DWORD PTR _v21$2[ebp]
	cmp	DWORD PTR [eax], 100			; 00000064H
	jl	SHORT $LN38@fill_brain
	mov	eax, DWORD PTR _v21$2[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	imul	edx, eax, 100
	mov	eax, DWORD PTR _v20$1[ebp]
	cmp	edx, DWORD PTR [eax]
	jle	$LN10@fill_brain
	mov	eax, DWORD PTR _v21$2[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	mov	ecx, eax
	mov	edx, DWORD PTR _v20$1[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	idiv	ecx
	test	edx, edx
	jne	$LN10@fill_brain
$LN38@fill_brain:

; 158  :         {
; 159  :             for (k = 0; k < (brain_ptr + brn_row)->row_count; ++k)

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN11@fill_brain
$LN9@fill_brain:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN11@fill_brain:
	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+4]
	jae	$LN10@fill_brain

; 160  :             {
; 161  :                 v107 = exs_ptr->entry[k] + 0.5;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	cvtsi2sd xmm0, DWORD PTR [ecx+eax*4+10]
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _v107$[ebp], xmm0

; 162  :                 //printf("v107 %f \n", v107);
; 163  :                 v110 = (brain_ptr + brn_row)->fsection[exs_ptr->section].shot_section[k][0] + (brain_ptr + brn_row)->fsection[exs_ptr->section].shot_section[k][1];

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	add	eax, DWORD PTR _brain_ptr
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	imul	edx, DWORD PTR [ecx+110], 3704
	lea	eax, DWORD PTR [eax+edx+12]
	imul	ecx, DWORD PTR _k$[ebp], 48
	add	eax, ecx
	mov	edx, 4
	imul	ecx, edx, 0
	imul	edx, DWORD PTR _brn_row$[ebp], 22236
	add	edx, DWORD PTR _brain_ptr
	mov	esi, DWORD PTR _exs_ptr$[ebp]
	imul	esi, DWORD PTR [esi+110], 3704
	lea	edx, DWORD PTR [edx+esi+12]
	imul	esi, DWORD PTR _k$[ebp], 48
	add	edx, esi
	mov	esi, 4
	shl	esi, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	addss	xmm0, DWORD PTR [edx+esi]
	movss	DWORD PTR _v110$[ebp], xmm0

; 164  :                 //printf("v110 %f \n", v110);
; 165  :                 if (v110 <= v107)

	movss	xmm0, DWORD PTR _v107$[ebp]
	comiss	xmm0, DWORD PTR _v110$[ebp]
	jb	SHORT $LN39@fill_brain

; 166  :                 {
; 167  :                     v26 = v107;

	movss	xmm0, DWORD PTR _v107$[ebp]
	movss	DWORD PTR _v26$[ebp], xmm0

; 168  :                 }

	jmp	SHORT $LN40@fill_brain
$LN39@fill_brain:

; 169  :                 else
; 170  :                 {
; 171  :                     v26 = v110;

	movss	xmm0, DWORD PTR _v110$[ebp]
	movss	DWORD PTR _v26$[ebp], xmm0
$LN40@fill_brain:

; 172  :                 }
; 173  : 
; 174  : 
; 175  :                 v109 = exs_ptr->entry[k] - 0.5;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	cvtsi2sd xmm0, DWORD PTR [ecx+eax*4+10]
	subsd	xmm0, QWORD PTR __real@3fe0000000000000
	cvtsd2ss xmm0, xmm0
	movss	DWORD PTR _v109$[ebp], xmm0

; 176  :                 v105 = (brain_ptr + brn_row)->fsection[exs_ptr->section].shot_section[k][0];

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	add	eax, DWORD PTR _brain_ptr
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	imul	edx, DWORD PTR [ecx+110], 3704
	lea	eax, DWORD PTR [eax+edx+12]
	imul	ecx, DWORD PTR _k$[ebp], 48
	add	eax, ecx
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR [eax+ecx]
	movss	DWORD PTR _v105$[ebp], xmm0

; 177  :                 if (v105 >= v109)

	movss	xmm0, DWORD PTR _v105$[ebp]
	comiss	xmm0, DWORD PTR _v109$[ebp]
	jb	SHORT $LN41@fill_brain

; 178  :                 {
; 179  :                     v27 = v109;

	movss	xmm0, DWORD PTR _v109$[ebp]
	movss	DWORD PTR _v27$[ebp], xmm0

; 180  :                 }

	jmp	SHORT $LN42@fill_brain
$LN41@fill_brain:

; 181  :                 else
; 182  :                 {
; 183  :                     v27 = v105;

	movss	xmm0, DWORD PTR _v105$[ebp]
	movss	DWORD PTR _v27$[ebp], xmm0
$LN42@fill_brain:

; 184  :                 }
; 185  :                 (brain_ptr + brn_row)->fsection[exs_ptr->section].shot_section[k][0] = v27;

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	add	eax, DWORD PTR _brain_ptr
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	imul	edx, DWORD PTR [ecx+110], 3704
	lea	eax, DWORD PTR [eax+edx+12]
	imul	ecx, DWORD PTR _k$[ebp], 48
	add	eax, ecx
	mov	edx, 4
	imul	ecx, edx, 0
	movss	xmm0, DWORD PTR _v27$[ebp]
	movss	DWORD PTR [eax+ecx], xmm0

; 186  :                 (brain_ptr + brn_row)->fsection[exs_ptr->section].shot_section[k][1] = v26 - v27;

	movss	xmm0, DWORD PTR _v26$[ebp]
	subss	xmm0, DWORD PTR _v27$[ebp]
	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	add	eax, DWORD PTR _brain_ptr
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	imul	edx, DWORD PTR [ecx+110], 3704
	lea	eax, DWORD PTR [eax+edx+12]
	imul	ecx, DWORD PTR _k$[ebp], 48
	add	eax, ecx
	mov	edx, 4
	shl	edx, 0
	movss	DWORD PTR [eax+edx], xmm0

; 187  :             }

	jmp	$LN9@fill_brain
$LN10@fill_brain:

; 188  : 
; 189  :         }
; 190  :         ++* v20;

	mov	eax, DWORD PTR _v20$1[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _v20$1[ebp]
	mov	DWORD PTR [edx], ecx

; 191  :     }

	jmp	$LN35@fill_brain
$LN8@fill_brain:

; 192  : 
; 193  :  /* --------------------------------------PART 3 scaling--------------------------------------------------------------- */
; 194  :     int num;
; 195  :     int m, n;
; 196  :     int temp_section;
; 197  : 
; 198  :     if (lseek(fd, 0, 0))

	mov	esi, esp
	push	0
	push	0
	mov	eax, DWORD PTR _fd
	push	eax
	call	DWORD PTR __imp__lseek
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	test	eax, eax
	je	SHORT $LN43@fill_brain

; 199  :         return -3;

	mov	eax, -3					; fffffffdH
	jmp	$LN1@fill_brain
$LN43@fill_brain:

; 200  : 
; 201  :     for (num = 0; num < brain_index_count; ++num)

	mov	DWORD PTR _num$[ebp], 0
	jmp	SHORT $LN14@fill_brain
$LN12@fill_brain:
	mov	eax, DWORD PTR _num$[ebp]
	add	eax, 1
	mov	DWORD PTR _num$[ebp], eax
$LN14@fill_brain:
	mov	eax, DWORD PTR _num$[ebp]
	cmp	eax, DWORD PTR _brain_index_count
	jge	$LN13@fill_brain

; 202  :     {
; 203  :         temp_section = 0;

	mov	DWORD PTR _temp_section$[ebp], 0

; 204  : 
; 205  : 
; 206  :         if ((brain_ptr + num)->section > 0)

	imul	eax, DWORD PTR _num$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	cmp	DWORD PTR [ecx+eax+8], 0
	jbe	$LN16@fill_brain
$LN17@fill_brain:

; 207  :         {
; 208  : 
; 209  :             do
; 210  :             {
; 211  :                 for (m = 0; m < (brain_ptr + num)->row_count; m++)

	mov	DWORD PTR _m$[ebp], 0
	jmp	SHORT $LN20@fill_brain
$LN18@fill_brain:
	mov	eax, DWORD PTR _m$[ebp]
	add	eax, 1
	mov	DWORD PTR _m$[ebp], eax
$LN20@fill_brain:
	imul	eax, DWORD PTR _num$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _m$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+4]
	jae	SHORT $LN19@fill_brain

; 212  :                 {
; 213  :                     for (n = 2; n < 12; ++n)

	mov	DWORD PTR _n$[ebp], 2
	jmp	SHORT $LN23@fill_brain
$LN21@fill_brain:
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax
$LN23@fill_brain:
	cmp	DWORD PTR _n$[ebp], 12			; 0000000cH
	jge	SHORT $LN22@fill_brain

; 214  :                     {
; 215  :                         (brain_ptr + num)->fsection[temp_section].shot_section[m][n] = 0;

	imul	eax, DWORD PTR _num$[ebp], 22236
	add	eax, DWORD PTR _brain_ptr
	imul	ecx, DWORD PTR _temp_section$[ebp], 3704
	lea	edx, DWORD PTR [eax+ecx+12]
	imul	eax, DWORD PTR _m$[ebp], 48
	add	edx, eax
	mov	ecx, DWORD PTR _n$[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx*4], xmm0

; 216  :                     }

	jmp	SHORT $LN21@fill_brain
$LN22@fill_brain:

; 217  :                 }

	jmp	$LN18@fill_brain
$LN19@fill_brain:

; 218  :                 ++temp_section;

	mov	eax, DWORD PTR _temp_section$[ebp]
	add	eax, 1
	mov	DWORD PTR _temp_section$[ebp], eax

; 219  :             } while (temp_section < (brain_ptr + num)->section);

	imul	eax, DWORD PTR _num$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _temp_section$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+8]
	jb	$LN17@fill_brain
$LN16@fill_brain:

; 220  : 
; 221  :         }
; 222  :     }

	jmp	$LN12@fill_brain
$LN13@fill_brain:

; 223  : 
; 224  :     float section_array_3[25][6] = { 0.0 };

	xorps	xmm0, xmm0
	movss	DWORD PTR _section_array_3$[ebp], xmm0
	push	596					; 00000254H
	push	0
	lea	eax, DWORD PTR _section_array_3$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 225  : 
; 226  :     int tmp_sec_num = sec_temp_num;

	mov	eax, DWORD PTR _sec_temp_num$[ebp]
	mov	DWORD PTR _tmp_sec_num$[ebp], eax
$LN24@fill_brain:

; 227  : 
; 228  :     int v47;
; 229  :     float v115;
; 230  :     float v46;
; 231  :     while (1)

	mov	eax, 1
	test	eax, eax
	je	$LN25@fill_brain

; 232  :     {
; 233  :         k = 0;

	mov	DWORD PTR _k$[ebp], 0

; 234  :         if ((read(fd, exs_ptr, 114)) != 114)

	mov	esi, esp
	push	114					; 00000072H
	mov	eax, DWORD PTR _exs_ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fd
	push	ecx
	call	DWORD PTR __imp__read
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 114				; 00000072H
	je	SHORT $LN45@fill_brain

; 235  :         {
; 236  :             printf("EXPERIEN section less then 114 bytes.\n");

	push	OFFSET ??_C@_0CH@KOJDAIDB@EXPERIEN?5section?5less?5then?5114?5@
	call	_printf
	add	esp, 4

; 237  :             break;

	jmp	$LN25@fill_brain
$LN45@fill_brain:

; 238  :         }
; 239  :         brn_row = find_row_brain_dat(exs_ptr->index, exs_ptr->row_count, exs_ptr->section);

	mov	eax, DWORD PTR _exs_ptr$[ebp]
	mov	ecx, DWORD PTR [eax+110]
	push	ecx
	mov	edx, DWORD PTR _exs_ptr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_find_row_brain_dat
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _brn_row$[ebp], eax

; 240  :         --tmp_sec_num;

	mov	eax, DWORD PTR _tmp_sec_num$[ebp]
	sub	eax, 1
	mov	DWORD PTR _tmp_sec_num$[ebp], eax

; 241  :         printf("tmp_sec_num %d \n", tmp_sec_num);

	mov	eax, DWORD PTR _tmp_sec_num$[ebp]
	push	eax
	push	OFFSET ??_C@_0BB@LCJJCINC@tmp_sec_num?5?$CFd?5?6@
	call	_printf
	add	esp, 8

; 242  :         v115 = exp(-tmp_sec_num * 0.0004);

	mov	eax, DWORD PTR _tmp_sec_num$[ebp]
	neg	eax
	cvtsi2sd xmm0, eax
	mulsd	xmm0, QWORD PTR __real@3f3a36e2eb1c432d
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	_exp
	add	esp, 8
	fstp	DWORD PTR _v115$[ebp]

; 243  :         printf("v115 %f \n", v115);

	cvtss2sd xmm0, DWORD PTR _v115$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_09LPDGMMCG@v115?5?$CFf?5?6@
	call	_printf
	add	esp, 12					; 0000000cH

; 244  :         if ((brain_ptr + brn_row)->row_count > 0)

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	cmp	DWORD PTR [ecx+eax+4], 0
	jbe	$LN46@fill_brain
$LN28@fill_brain:

; 245  :         {
; 246  :             do
; 247  :             {
; 248  :                 v46 = (exs_ptr->entry[k] - (brain_ptr + brn_row)->fsection[exs_ptr->section].shot_section[k][0]) / (brain_ptr + brn_row)->fsection[exs_ptr->section].shot_section[k][1] * 10;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	cvtsi2ss xmm0, DWORD PTR [ecx+eax*4+10]
	imul	edx, DWORD PTR _brn_row$[ebp], 22236
	add	edx, DWORD PTR _brain_ptr
	mov	eax, DWORD PTR _exs_ptr$[ebp]
	imul	ecx, DWORD PTR [eax+110], 3704
	lea	edx, DWORD PTR [edx+ecx+12]
	imul	eax, DWORD PTR _k$[ebp], 48
	add	edx, eax
	mov	ecx, 4
	imul	eax, ecx, 0
	subss	xmm0, DWORD PTR [edx+eax]
	imul	ecx, DWORD PTR _brn_row$[ebp], 22236
	add	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _exs_ptr$[ebp]
	imul	eax, DWORD PTR [edx+110], 3704
	lea	ecx, DWORD PTR [ecx+eax+12]
	imul	edx, DWORD PTR _k$[ebp], 48
	add	ecx, edx
	mov	eax, 4
	shl	eax, 0
	divss	xmm0, DWORD PTR [ecx+eax]
	mulss	xmm0, DWORD PTR __real@41200000
	movss	DWORD PTR _v46$[ebp], xmm0

; 249  :                 v47 = floor(v46);

	cvtss2sd xmm0, DWORD PTR _v46$[ebp]
	mov	esi, esp
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	call	__ftol2_sse
	mov	DWORD PTR _v47$[ebp], eax

; 250  :                 if (v47 <= 0)

	cmp	DWORD PTR _v47$[ebp], 0
	jg	SHORT $LN47@fill_brain

; 251  :                     v47 = 0;

	mov	DWORD PTR _v47$[ebp], 0
$LN47@fill_brain:

; 252  :                 if (v47 >= 9)

	cmp	DWORD PTR _v47$[ebp], 9
	jl	SHORT $LN48@fill_brain

; 253  :                 {
; 254  :                     v47 = 9;

	mov	DWORD PTR _v47$[ebp], 9

; 255  :                 }

	jmp	SHORT $LN50@fill_brain
$LN48@fill_brain:

; 256  :                 else
; 257  :                 {
; 258  :                     if (v47 <= 0)

	cmp	DWORD PTR _v47$[ebp], 0
	jg	SHORT $LN50@fill_brain

; 259  :                         v47 = 0;

	mov	DWORD PTR _v47$[ebp], 0
$LN50@fill_brain:

; 260  : 
; 261  :                 }
; 262  :                 (brain_ptr + brn_row)->fsection[exs_ptr->section].shot_section[k][v47 + 2] = (brain_ptr + brn_row)->fsection[exs_ptr->section].shot_section[k][v47 + 2] + v115;

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	add	eax, DWORD PTR _brain_ptr
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	imul	edx, DWORD PTR [ecx+110], 3704
	lea	eax, DWORD PTR [eax+edx+12]
	imul	ecx, DWORD PTR _k$[ebp], 48
	add	eax, ecx
	mov	edx, DWORD PTR _v47$[ebp]
	movss	xmm0, DWORD PTR [eax+edx*4+8]
	addss	xmm0, DWORD PTR _v115$[ebp]
	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	add	eax, DWORD PTR _brain_ptr
	mov	ecx, DWORD PTR _exs_ptr$[ebp]
	imul	edx, DWORD PTR [ecx+110], 3704
	lea	eax, DWORD PTR [eax+edx+12]
	imul	ecx, DWORD PTR _k$[ebp], 48
	add	eax, ecx
	mov	edx, DWORD PTR _v47$[ebp]
	movss	DWORD PTR [eax+edx*4+8], xmm0

; 263  :                 ++k;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 264  :             } while (k < (brain_ptr + brn_row)->row_count);

	imul	eax, DWORD PTR _brn_row$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR [ecx+eax+4]
	jb	$LN28@fill_brain

; 265  :             section_array_3[brn_row][exs_ptr->section] = section_array_3[brn_row][exs_ptr->section] + v115;

	imul	eax, DWORD PTR _brn_row$[ebp], 24
	lea	ecx, DWORD PTR _section_array_3$[ebp+eax]
	mov	edx, DWORD PTR _exs_ptr$[ebp]
	mov	eax, DWORD PTR [edx+110]
	movss	xmm0, DWORD PTR [ecx+eax*4]
	addss	xmm0, DWORD PTR _v115$[ebp]
	imul	ecx, DWORD PTR _brn_row$[ebp], 24
	lea	edx, DWORD PTR _section_array_3$[ebp+ecx]
	mov	eax, DWORD PTR _exs_ptr$[ebp]
	mov	ecx, DWORD PTR [eax+110]
	movss	DWORD PTR [edx+ecx*4], xmm0
$LN46@fill_brain:

; 266  :         }
; 267  :     }

	jmp	$LN24@fill_brain
$LN25@fill_brain:

; 268  : 
; 269  : 
; 270  :     /* --------------------------------------PART 4--------------------------------------------------------------- */
; 271  : 
; 272  : 
; 273  : 
; 274  : 
; 275  : 
; 276  : 
; 277  : 
; 278  : 
; 279  : 
; 280  : 
; 281  : 
; 282  : 
; 283  : 
; 284  : 
; 285  : 
; 286  : 
; 287  : 
; 288  : 
; 289  : 
; 290  : 
; 291  : 
; 292  :     save_brain("TACDATA/BRAIN2.DAT", brain_ptr);

	mov	eax, DWORD PTR _brain_ptr
	push	eax
	push	OFFSET ??_C@_0BD@CAPAPHJL@TACDATA?1BRAIN2?4DAT@
	call	_save_brain
	add	esp, 8

; 293  :     free(brain_ptr);

	mov	esi, esp
	mov	eax, DWORD PTR _brain_ptr
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 294  :     free(exs_ptr);

	mov	esi, esp
	mov	eax, DWORD PTR _exs_ptr$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 295  :     return 0;

	xor	eax, eax
$LN1@fill_brain:

; 296  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN55@fill_brain
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2096				; 00000830H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN55@fill_brain:
	DD	2
	DD	$LN54@fill_brain
$LN54@fill_brain:
	DD	-704					; fffffd40H
	DD	600					; 00000258H
	DD	$LN52@fill_brain
	DD	-1468					; fffffa44H
	DD	600					; 00000258H
	DD	$LN53@fill_brain
$LN53@fill_brain:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	95					; 0000005fH
	DB	51					; 00000033H
	DB	0
$LN52@fill_brain:
	DB	115					; 00000073H
	DB	101					; 00000065H
	DB	99					; 00000063H
	DB	116					; 00000074H
	DB	105					; 00000069H
	DB	111					; 0000006fH
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	97					; 00000061H
	DB	114					; 00000072H
	DB	114					; 00000072H
	DB	97					; 00000061H
	DB	121					; 00000079H
	DB	95					; 0000005fH
	DB	50					; 00000032H
	DB	0
_fill_brain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\TACP\C_Sources\calc_brain.c
;	COMDAT _find_row_brain_dat
_TEXT	SEGMENT
_v9$1 = -104						; size = 4
_n$2 = -92						; size = 4
_l$3 = -80						; size = 4
_k$4 = -68						; size = 4
_j$5 = -56						; size = 4
_i$6 = -44						; size = 4
_brain_index_count_temp$ = -32				; size = 4
_v20$ = -20						; size = 4
_k$ = -8						; size = 4
_index$ = 8						; size = 4
_row_count$ = 12					; size = 4
_section$ = 16						; size = 4
_find_row_brain_dat PROC				; COMDAT

; 313  : int find_row_brain_dat(int index, int row_count, int section) {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-108]
	mov	ecx, 27					; 0000001bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0DAB258A_calc_brain@c
	call	@__CheckForDebuggerJustMyCode@4

; 314  :     int k = 0;

	mov	DWORD PTR _k$[ebp], 0

; 315  :     int v20 = 0;

	mov	DWORD PTR _v20$[ebp], 0

; 316  :     int brain_index_count_temp = 0;

	mov	DWORD PTR _brain_index_count_temp$[ebp], 0

; 317  : 
; 318  :     if (brain_index_count > 0)

	cmp	DWORD PTR _brain_index_count, 0
	jle	SHORT $lebel_8$27
$LN2@find_row_b:

; 319  :     {
; 320  :         while (index != (brain_ptr + k)->index)

	imul	eax, DWORD PTR _k$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _index$[ebp]
	cmp	edx, DWORD PTR [ecx+eax]
	je	SHORT $LN3@find_row_b

; 321  :         {
; 322  :             ++k;

	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax

; 323  :             if (k >= brain_index_count)

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _brain_index_count
	jl	SHORT $LN20@find_row_b

; 324  :                 goto lebel_8;

	jmp	SHORT $lebel_8$27
$LN20@find_row_b:

; 325  :         }

	jmp	SHORT $LN2@find_row_b
$LN3@find_row_b:

; 326  :         v20 = 1;

	mov	DWORD PTR _v20$[ebp], 1

; 327  :         if (row_count != 0)

	cmp	DWORD PTR _row_count$[ebp], 0
	je	SHORT $LN21@find_row_b

; 328  :             row_count = (brain_ptr + k)->row_count;

	imul	eax, DWORD PTR _k$[ebp], 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _row_count$[ebp], edx
$LN21@find_row_b:

; 329  :         brain_index_count_temp = k;

	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _brain_index_count_temp$[ebp], eax
$lebel_8$27:

; 330  :     }
; 331  : 
; 332  : lebel_8:
; 333  :     if (!v20) {

	cmp	DWORD PTR _v20$[ebp], 0
	jne	$LN22@find_row_b

; 334  :         if (brain_index_count >= 25)

	cmp	DWORD PTR _brain_index_count, 25	; 00000019H
	jl	SHORT $LN23@find_row_b

; 335  :             return -1;

	or	eax, -1
	jmp	$LN1@find_row_b
$LN23@find_row_b:

; 336  :         brain_index_count_temp = brain_index_count;

	mov	eax, DWORD PTR _brain_index_count
	mov	DWORD PTR _brain_index_count_temp$[ebp], eax

; 337  :         (brain_ptr + brain_index_count)->index = index;

	imul	eax, DWORD PTR _brain_index_count, 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _index$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 338  :         (brain_ptr + brain_index_count)->row_count = row_count;

	imul	eax, DWORD PTR _brain_index_count, 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _row_count$[ebp]
	mov	DWORD PTR [ecx+eax+4], edx

; 339  :         (brain_ptr + brain_index_count)->section = section;

	imul	eax, DWORD PTR _brain_index_count, 22236
	mov	ecx, DWORD PTR _brain_ptr
	mov	edx, DWORD PTR _section$[ebp]
	mov	DWORD PTR [ecx+eax+8], edx

; 340  : 
; 341  :         int i;
; 342  :         int j;
; 343  :         int k;
; 344  :         int l;
; 345  :         int n;
; 346  :         int v9 = 0;

	mov	DWORD PTR _v9$1[ebp], 0

; 347  :         for (i = 0; i < 6; ++i)

	mov	DWORD PTR _i$6[ebp], 0
	jmp	SHORT $LN6@find_row_b
$LN4@find_row_b:
	mov	eax, DWORD PTR _i$6[ebp]
	add	eax, 1
	mov	DWORD PTR _i$6[ebp], eax
$LN6@find_row_b:
	cmp	DWORD PTR _i$6[ebp], 6
	jge	$LN5@find_row_b

; 348  :         {
; 349  : 
; 350  :             for (j = 0; j < row_count; ++j)

	mov	DWORD PTR _j$5[ebp], 0
	jmp	SHORT $LN9@find_row_b
$LN7@find_row_b:
	mov	eax, DWORD PTR _j$5[ebp]
	add	eax, 1
	mov	DWORD PTR _j$5[ebp], eax
$LN9@find_row_b:
	mov	eax, DWORD PTR _j$5[ebp]
	cmp	eax, DWORD PTR _row_count$[ebp]
	jge	$LN8@find_row_b

; 351  :             {
; 352  :                 (brain_ptr + brain_index_count)->fsection[i].shot_section[j][0] = -0.5;

	imul	eax, DWORD PTR _brain_index_count, 22236
	add	eax, DWORD PTR _brain_ptr
	imul	ecx, DWORD PTR _i$6[ebp], 3704
	lea	edx, DWORD PTR [eax+ecx+12]
	imul	eax, DWORD PTR _j$5[ebp], 48
	add	edx, eax
	mov	ecx, 4
	imul	eax, ecx, 0
	movss	xmm0, DWORD PTR __real@bf000000
	movss	DWORD PTR [edx+eax], xmm0

; 353  :                 (brain_ptr + brain_index_count)->fsection[i].shot_section[j][1] = 1.0;

	imul	eax, DWORD PTR _brain_index_count, 22236
	add	eax, DWORD PTR _brain_ptr
	imul	ecx, DWORD PTR _i$6[ebp], 3704
	lea	edx, DWORD PTR [eax+ecx+12]
	imul	eax, DWORD PTR _j$5[ebp], 48
	add	edx, eax
	mov	ecx, 4
	shl	ecx, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0

; 354  :                 for (k = 2; k < 12; ++k)

	mov	DWORD PTR _k$4[ebp], 2
	jmp	SHORT $LN12@find_row_b
$LN10@find_row_b:
	mov	eax, DWORD PTR _k$4[ebp]
	add	eax, 1
	mov	DWORD PTR _k$4[ebp], eax
$LN12@find_row_b:
	cmp	DWORD PTR _k$4[ebp], 12			; 0000000cH
	jge	SHORT $LN11@find_row_b

; 355  :                 {
; 356  :                     (brain_ptr + brain_index_count)->fsection[i].shot_section[j][k] = 0;

	imul	eax, DWORD PTR _brain_index_count, 22236
	add	eax, DWORD PTR _brain_ptr
	imul	ecx, DWORD PTR _i$6[ebp], 3704
	lea	edx, DWORD PTR [eax+ecx+12]
	imul	eax, DWORD PTR _j$5[ebp], 48
	add	edx, eax
	mov	ecx, DWORD PTR _k$4[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [edx+ecx*4], xmm0

; 357  :                 }

	jmp	SHORT $LN10@find_row_b
$LN11@find_row_b:

; 358  : 
; 359  :             }

	jmp	$LN7@find_row_b
$LN8@find_row_b:

; 360  :             (brain_ptr + brain_index_count)->fsection[i].total = 0;

	imul	eax, DWORD PTR _brain_index_count, 22236
	add	eax, DWORD PTR _brain_ptr
	imul	ecx, DWORD PTR _i$6[ebp], 3704
	xorps	xmm0, xmm0
	movss	DWORD PTR [eax+ecx+1212], xmm0

; 361  :             for (l = 0; l < 25; ++l)

	mov	DWORD PTR _l$3[ebp], 0
	jmp	SHORT $LN15@find_row_b
$LN13@find_row_b:
	mov	eax, DWORD PTR _l$3[ebp]
	add	eax, 1
	mov	DWORD PTR _l$3[ebp], eax
$LN15@find_row_b:
	cmp	DWORD PTR _l$3[ebp], 25			; 00000019H
	jge	$LN14@find_row_b

; 362  :             {
; 363  :                 for (n = 0; n < 25; ++n)

	mov	DWORD PTR _n$2[ebp], 0
	jmp	SHORT $LN18@find_row_b
$LN16@find_row_b:
	mov	eax, DWORD PTR _n$2[ebp]
	add	eax, 1
	mov	DWORD PTR _n$2[ebp], eax
$LN18@find_row_b:
	cmp	DWORD PTR _n$2[ebp], 25			; 00000019H
	jge	SHORT $LN17@find_row_b

; 364  :                 {
; 365  :                     if (l = n)//why it not work for [0][0] ?

	mov	eax, DWORD PTR _n$2[ebp]
	mov	DWORD PTR _l$3[ebp], eax
	cmp	DWORD PTR _l$3[ebp], 0
	je	SHORT $LN24@find_row_b

; 366  :                         (brain_ptr + brain_index_count)->fsection[i].long_section[l][n] = 1;

	imul	eax, DWORD PTR _brain_index_count, 22236
	add	eax, DWORD PTR _brain_ptr
	imul	ecx, DWORD PTR _i$6[ebp], 3704
	lea	edx, DWORD PTR [eax+ecx+12]
	imul	eax, DWORD PTR _l$3[ebp], 100
	lea	ecx, DWORD PTR [edx+eax+1204]
	mov	edx, DWORD PTR _n$2[ebp]
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [ecx+edx*4], xmm0
	jmp	SHORT $LN25@find_row_b
$LN24@find_row_b:

; 367  :                     else
; 368  :                         (brain_ptr + brain_index_count)->fsection[i].long_section[l][n] = 0;

	imul	eax, DWORD PTR _brain_index_count, 22236
	add	eax, DWORD PTR _brain_ptr
	imul	ecx, DWORD PTR _i$6[ebp], 3704
	lea	edx, DWORD PTR [eax+ecx+12]
	imul	eax, DWORD PTR _l$3[ebp], 100
	lea	ecx, DWORD PTR [edx+eax+1204]
	mov	edx, DWORD PTR _n$2[ebp]
	xorps	xmm0, xmm0
	movss	DWORD PTR [ecx+edx*4], xmm0
$LN25@find_row_b:

; 369  :                 }

	jmp	$LN16@find_row_b
$LN17@find_row_b:

; 370  :             }

	jmp	$LN13@find_row_b
$LN14@find_row_b:

; 371  :             (brain_ptr + brain_index_count)->fsection[i].long_section[0][0] = 1;

	imul	eax, DWORD PTR _brain_index_count, 22236
	add	eax, DWORD PTR _brain_ptr
	imul	ecx, DWORD PTR _i$6[ebp], 3704
	lea	edx, DWORD PTR [eax+ecx+12]
	mov	eax, 100				; 00000064H
	imul	ecx, eax, 0
	lea	edx, DWORD PTR [edx+ecx+1204]
	mov	eax, 4
	imul	ecx, eax, 0
	movss	xmm0, DWORD PTR __real@3f800000
	movss	DWORD PTR [edx+ecx], xmm0

; 372  : 
; 373  :         }

	jmp	$LN4@find_row_b
$LN5@find_row_b:

; 374  :         ++brain_index_count;

	mov	eax, DWORD PTR _brain_index_count
	add	eax, 1
	mov	DWORD PTR _brain_index_count, eax
$LN22@find_row_b:

; 375  :     }
; 376  : 
; 377  :     return brain_index_count_temp;

	mov	eax, DWORD PTR _brain_index_count_temp$[ebp]
$LN1@find_row_b:

; 378  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 300				; 0000012cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_find_row_brain_dat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\TACP\C_Sources\calc_brain.c
;	COMDAT _save_brain
_TEXT	SEGMENT
tv74 = -229						; size = 1
_i$ = -32						; size = 4
_c$ = -20						; size = 4
_fp$ = -8						; size = 4
_filename$ = 8						; size = 4
_br$ = 12						; size = 4
_save_brain PROC					; COMDAT

; 409  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-40]
	mov	ecx, 10					; 0000000aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0DAB258A_calc_brain@c
	call	@__CheckForDebuggerJustMyCode@4

; 410  :     FILE* fp;
; 411  :     uint8_t* c;
; 412  :     if ((fp = fopen(filename, "wb")) == NULL)

	mov	esi, esp
	push	OFFSET ??_C@_02GMLFBBN@wb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN5@save_brain

; 413  :     {
; 414  :         perror("Error occured while opening file");

	mov	esi, esp
	push	OFFSET ??_C@_0CB@KBMNMHCO@Error?5occured?5while?5opening?5fil@
	call	DWORD PTR __imp__perror
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 415  :         return 1;

	mov	eax, 1
	jmp	SHORT $LN1@save_brain
$LN5@save_brain:

; 416  :     }
; 417  :     // устанавливаем указатель на начало структуры
; 418  :     c = (uint8_t*)br;

	mov	eax, DWORD PTR _br$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 419  :     // посимвольно записываем в файл структуру
; 420  :     int i;
; 421  :     for (i = 0; i < 555900; i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@save_brain
$LN2@save_brain:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@save_brain:
	cmp	DWORD PTR _i$[ebp], 555900		; 00087b7cH
	jge	SHORT $LN3@save_brain

; 422  :     {
; 423  :         putc(*c++, fp);

	mov	eax, DWORD PTR _c$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv74[ebp], cl
	mov	edx, DWORD PTR _c$[ebp]
	add	edx, 1
	mov	DWORD PTR _c$[ebp], edx
	mov	esi, esp
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	movzx	ecx, BYTE PTR tv74[ebp]
	push	ecx
	call	DWORD PTR __imp__putc
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp

; 424  :     }

	jmp	SHORT $LN2@save_brain
$LN3@save_brain:

; 425  :     fclose(fp);

	mov	esi, esp
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 426  :     return 0;

	xor	eax, eax
$LN1@save_brain:

; 427  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_save_brain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\TACP\C_Sources\calc_brain.c
;	COMDAT _load_brain
_TEXT	SEGMENT
_i$ = -32						; size = 4
_c$ = -20						; size = 4
_fp$ = -8						; size = 4
_filename$ = 8						; size = 4
_struc_count$ = 12					; size = 4
_load_brain PROC					; COMDAT

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-36]
	mov	ecx, 9
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __0DAB258A_calc_brain@c
	call	@__CheckForDebuggerJustMyCode@4

; 385  :     FILE* fp;
; 386  :     char* c;
; 387  :     int i;
; 388  :     // выделяем память для количества данных
; 389  :     if ((fp = fopen(filename, "rb")) == NULL)

	mov	esi, esp
	push	OFFSET ??_C@_02JDPG@rb@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _fp$[ebp], eax
	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN4@load_brain

; 390  :     {
; 391  :         perror("Error occured while opening file");

	mov	esi, esp
	push	OFFSET ??_C@_0CB@KBMNMHCO@Error?5occured?5while?5opening?5fil@
	call	DWORD PTR __imp__perror
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 392  :         return 1;

	mov	eax, 1
	jmp	SHORT $LN1@load_brain
$LN4@load_brain:

; 393  :     }
; 394  :     // выделяем память для считанного массива структур
; 395  :     brain_ptr = (struct brain_struct*)malloc(struc_count * sizeof(struct brain_struct));

	imul	eax, DWORD PTR _struc_count$[ebp], 22236
	mov	esi, esp
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _brain_ptr, eax

; 396  :     c = (char*)brain_ptr;

	mov	eax, DWORD PTR _brain_ptr
	mov	DWORD PTR _c$[ebp], eax
$LN2@load_brain:

; 397  :     // после записи считываем посимвольно из файла
; 398  :     while ((i = getc(fp)) != EOF)

	mov	esi, esp
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__getc
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR _i$[ebp], eax
	cmp	DWORD PTR _i$[ebp], -1
	je	SHORT $LN3@load_brain

; 399  :     {
; 400  :         *c = i;

	mov	eax, DWORD PTR _c$[ebp]
	mov	cl, BYTE PTR _i$[ebp]
	mov	BYTE PTR [eax], cl

; 401  :         c++;

	mov	eax, DWORD PTR _c$[ebp]
	add	eax, 1
	mov	DWORD PTR _c$[ebp], eax

; 402  :     }

	jmp	SHORT $LN2@load_brain
$LN3@load_brain:

; 403  :     fclose(fp);

	mov	esi, esp
	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp

; 404  :     return 0;

	xor	eax, eax
$LN1@load_brain:

; 405  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_load_brain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 963  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 646  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __A2143F22_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
