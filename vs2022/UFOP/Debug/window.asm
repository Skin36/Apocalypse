; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31933.0 

	TITLE	D:\FreeApoc\Apocalypse\vs2022\UFOP\Debug\window.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_m_surface
PUBLIC	_m_must_lock_surface
PUBLIC	_m_texture_coord_in_surface
_BSS	SEGMENT
_m_surface DD	01H DUP (?)
_m_must_lock_surface DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_m_renderer:DWORD
COMM	_screen_texture:DWORD
COMM	_image:DWORD
COMM	_m_texture:DWORD
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

_m_texture_coord_in_surface DB 010H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_m_window:DWORD
_DATA	ENDS
msvcjmc	SEGMENT
__D0DFFAC6_winpackagefamily@h DB 01H
__D0D0F397_winapifamily@h DB 01H
__1ADC5BE7_begin_code@h DB 01H
__8D67BD40_close_code@h DB 01H
__DDEA9788_SDL_platform@h DB 01H
__94A3FDDD_sdkddkver@h DB 01H
__4BD2FD7B_SDL_config@h DB 01H
__CD417A16_concurrencysal@h DB 01H
__18C11F8D_sal@h DB 01H
__BD42D05E_vadefs@h DB 01H
__2DC9DF70_vcruntime@h DB 01H
__6569C2CA_corecrt@h DB 01H
__C9393812_stddef@h DB 01H
__F19000F7_stdarg@h DB 01H
__EBA520B6_SDL_stdinc@h DB 01H
__C6E6D7CD_SDL_main@h DB 01H
__C819AA9E_SDL_assert@h DB 01H
__D7AB785A_SDL_atomic@h DB 01H
__7CDE7143_SDL_error@h DB 01H
__C264589F_SDL_endian@h DB 01H
__BF5E9F8E_SDL_mutex@h DB 01H
__741AE07E_corecrt_math@h DB 01H
__91D68F2D_math@h DB 01H
__C66E9EB9_vcruntime_startup@h DB 01H
__F6CEABBE_corecrt_startup@h DB 01H
__61BDDCD5_corecrt_wprocess@h DB 01H
__F57902D7_process@h DB 01H
__0C4DD541_SDL_thread@h DB 01H
__1FA23C7D_SDL_rwops@h DB 01H
__4BA16835_SDL_audio@h DB 01H
__A80A68DA_SDL_clipboard@h DB 01H
__99FA516B_intrin0@inl@h DB 01H
__552C563B_setjmp@h DB 01H
__3BCDA13C_mmintrin@h DB 01H
__6C20D4D3_corecrt_malloc@h DB 01H
__20BB4341_malloc@h DB 01H
__AD1CB324_xmmintrin@h DB 01H
__C87E3AE8_emmintrin@h DB 01H
__17DF5261_pmmintrin@h DB 01H
__A70621E3_tmmintrin@h DB 01H
__8E3D3460_smmintrin@h DB 01H
__EB5FBDAC_nmmintrin@h DB 01H
__3EE447E2_wmmintrin@h DB 01H
__F5700AE5_zmmintrin@h DB 01H
__C264A82F_immintrin@h DB 01H
__78A7496A_ammintrin@h DB 01H
__74E2446C_mm3dnow@h DB 01H
__731AEA4C_intrin@h DB 01H
__68067E44_SDL_cpuinfo@h DB 01H
__64E89E41_SDL_pixels@h DB 01H
__BFEA0781_SDL_rect@h DB 01H
__03192F33_SDL_blendmode@h DB 01H
__00CE5C3F_SDL_surface@h DB 01H
__D71AB72D_SDL_video@h DB 01H
__0166E892_SDL_scancode@h DB 01H
__1B40CEEC_SDL_keycode@h DB 01H
__92B90C80_SDL_keyboard@h DB 01H
__41FFAFA3_SDL_mouse@h DB 01H
__9364B404_SDL_joystick@h DB 01H
__049FB5AB_SDL_sensor@h DB 01H
__5B890460_SDL_gamecontroller@h DB 01H
__362302C9_SDL_quit@h DB 01H
__EB78B272_SDL_touch@h DB 01H
__18F5D7F5_SDL_gesture@h DB 01H
__9C10120D_SDL_events@h DB 01H
__D54FBDEE_SDL_filesystem@h DB 01H
__627295A5_SDL_haptic@h DB 01H
__57D222F1_SDL_hints@h DB 01H
__28D3E821_SDL_loadso@h DB 01H
__52E9A77B_SDL_log@h DB 01H
__E1B8B927_SDL_messagebox@h DB 01H
__28C501EE_SDL_metal@h DB 01H
__512DBC7B_SDL_power@h DB 01H
__75481EC3_SDL_render@h DB 01H
__ECCEE624_SDL_shape@h DB 01H
__D14E8A6D_SDL_system@h DB 01H
__596BF456_SDL_timer@h DB 01H
__130AA0EB_SDL_version@h DB 01H
__A8160445_SDL_locale@h DB 01H
__C1EAB8A4_SDL_misc@h DB 01H
__0E484B1D_SDL@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__6E2CA68A_stdbool@h DB 01H
__111BF5DD_window@h DB 01H
__1846F8BA_keyboard@h DB 01H
__86C92C55_window@c DB 01H
msvcjmc	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_video_init
PUBLIC	_screenshot
PUBLIC	_palette_correct
PUBLIC	_palette_mix
PUBLIC	_out_to_screen
PUBLIC	_out_to_screen_2
PUBLIC	_close_video
PUBLIC	_set_palette
PUBLIC	_screen_data_init
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_0BI@KCEBAPDC@ERROR?3?5init?5SDL?5video?4?5@ ; `string'
PUBLIC	??_C@_07EDGOICEI@?$CFs?5?$CFs?5?6@		; `string'
PUBLIC	??_C@_0BK@GNKLFGAB@ERROR?3?5get?5display?5mode?4?5@ ; `string'
PUBLIC	??_C@_0L@CLHOAHDA@Apocalypse@			; `string'
PUBLIC	??_C@_0BI@KAPODFJF@ERROR?3?5created?5window?4?5@ ; `string'
PUBLIC	??_C@_0BM@IIAPPAFM@Creating?5surface?5failed?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0BP@JCGNJGIA@ERROR?3?5created?5screen?5surface?4@ ; `string'
PUBLIC	??_C@_04ILNEAJIO@?$CFs?5?6@			; `string'
PUBLIC	??_C@_0DG@MBLAMNOJ@ERROR?3?5screen?5data?5invalid?5surf@ ; `string'
EXTRN	_SDL_GetError:PROC
EXTRN	__imp__exit:PROC
EXTRN	_SDL_RWFromFile:PROC
EXTRN	_SDL_SetPaletteColors:PROC
EXTRN	_SDL_CreateRGBSurfaceFrom:PROC
EXTRN	_SDL_CreateRGBSurfaceWithFormatFrom:PROC
EXTRN	_SDL_SetSurfacePalette:PROC
EXTRN	_SDL_SaveBMP_RW:PROC
EXTRN	_SDL_VideoQuit:PROC
EXTRN	_SDL_GetCurrentDisplayMode:PROC
EXTRN	_SDL_CreateWindow:PROC
EXTRN	_SDL_DestroyWindow:PROC
EXTRN	_SDL_Log:PROC
EXTRN	_SDL_CreateRenderer:PROC
EXTRN	_SDL_CreateTextureFromSurface:PROC
EXTRN	_SDL_RenderClear:PROC
EXTRN	_SDL_RenderCopy:PROC
EXTRN	_SDL_RenderPresent:PROC
EXTRN	_SDL_DestroyRenderer:PROC
EXTRN	_SDL_Delay:PROC
EXTRN	_SDL_Init:PROC
EXTRN	_SDL_Quit:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_temp_screen_buffer:DWORD
EXTRN	_current_pal:DWORD
EXTRN	_screenx:WORD
EXTRN	_screenx_1:WORD
EXTRN	_screeny:WORD
EXTRN	_screeny_1:WORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0DG@MBLAMNOJ@ERROR?3?5screen?5data?5invalid?5surf@
CONST	SEGMENT
??_C@_0DG@MBLAMNOJ@ERROR?3?5screen?5data?5invalid?5surf@ DB 'ERROR: scree'
	DB	'n data invalid surface and offset params.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04ILNEAJIO@?$CFs?5?6@
CONST	SEGMENT
??_C@_04ILNEAJIO@?$CFs?5?6@ DB '%s ', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JCGNJGIA@ERROR?3?5created?5screen?5surface?4@
CONST	SEGMENT
??_C@_0BP@JCGNJGIA@ERROR?3?5created?5screen?5surface?4@ DB 'ERROR: create'
	DB	'd screen surface.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIAPPAFM@Creating?5surface?5failed?3?5?$CFs@
CONST	SEGMENT
??_C@_0BM@IIAPPAFM@Creating?5surface?5failed?3?5?$CFs@ DB 'Creating surfa'
	DB	'ce failed: %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KAPODFJF@ERROR?3?5created?5window?4?5@
CONST	SEGMENT
??_C@_0BI@KAPODFJF@ERROR?3?5created?5window?4?5@ DB 'ERROR: created windo'
	DB	'w. ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CLHOAHDA@Apocalypse@
CONST	SEGMENT
??_C@_0L@CLHOAHDA@Apocalypse@ DB 'Apocalypse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GNKLFGAB@ERROR?3?5get?5display?5mode?4?5@
CONST	SEGMENT
??_C@_0BK@GNKLFGAB@ERROR?3?5get?5display?5mode?4?5@ DB 'ERROR: get displa'
	DB	'y mode. ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EDGOICEI@?$CFs?5?$CFs?5?6@
CONST	SEGMENT
??_C@_07EDGOICEI@?$CFs?5?$CFs?5?6@ DB '%s %s ', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KCEBAPDC@ERROR?3?5init?5SDL?5video?4?5@
CONST	SEGMENT
??_C@_0BI@KCEBAPDC@ERROR?3?5init?5SDL?5video?4?5@ DB 'ERROR: init SDL vid'
	DB	'eo. ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	022H
	DW	0147H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	022H
	DW	0131H
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	push	ebp
	mov	ebp, esp
	pop	ebp
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\UFOP\C_Sources\window.c
;	COMDAT _screen_data_init
_TEXT	SEGMENT
_ret_val$ = -8						; size = 4
_screen_buffer$ = 8					; size = 4
_surface_width$ = 12					; size = 4
_surface_height$ = 16					; size = 4
_img_width$ = 20					; size = 4
_img_height$ = 24					; size = 4
_offset_x$ = 28						; size = 4
_offset_y$ = 32						; size = 4
_screen_data_init PROC					; COMDAT

; 290  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-12]
	mov	ecx, 3
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __86C92C55_window@c
	call	@__CheckForDebuggerJustMyCode@4

; 291  : 	int ret_val = 0;

	mov	DWORD PTR _ret_val$[ebp], 0

; 292  : 	//ret_val |= destroy();
; 293  : 	m_surface = SDL_CreateRGBSurfaceWithFormatFrom(screen_buffer, surface_width, surface_height, 8, 3 * surface_width, SDL_PIXELFORMAT_INDEX8);

	push	318769153				; 13000801H
	imul	eax, DWORD PTR _surface_width$[ebp], 3
	push	eax
	push	8
	mov	ecx, DWORD PTR _surface_height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _surface_width$[ebp]
	push	edx
	mov	eax, DWORD PTR _screen_buffer$[ebp]
	push	eax
	call	_SDL_CreateRGBSurfaceWithFormatFrom
	add	esp, 24					; 00000018H
	mov	DWORD PTR _m_surface, eax

; 294  : 
; 295  : 
; 296  : 
; 297  : 	if (m_surface == NULL) {

	cmp	DWORD PTR _m_surface, 0
	jne	SHORT $LN2@screen_dat

; 298  : 		SDL_Log("Creating surface failed: %s", SDL_GetError());

	call	_SDL_GetError
	push	eax
	push	OFFSET ??_C@_0BM@IIAPPAFM@Creating?5surface?5failed?3?5?$CFs@
	call	_SDL_Log
	add	esp, 8

; 299  : 		//stbi_image_free(screen_buffer);
; 300  : 		exit(1);

	mov	esi, esp
	push	1
	call	DWORD PTR __imp__exit
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@screen_dat:

; 301  : 	}
; 302  : 
; 303  : 	if (!m_surface)

	cmp	DWORD PTR _m_surface, 0
	jne	SHORT $LN3@screen_dat

; 304  : 	{
; 305  : 		printf("%s \n", "ERROR: created screen surface.");

	push	OFFSET ??_C@_0BP@JCGNJGIA@ERROR?3?5created?5screen?5surface?4@
	push	OFFSET ??_C@_04ILNEAJIO@?$CFs?5?6@
	call	_printf
	add	esp, 8

; 306  : 		return -1;

	or	eax, -1
	jmp	SHORT $LN6@screen_dat
$LN3@screen_dat:

; 307  : 	}
; 308  : 	//m_must_lock_surface = SDL_MUSTLOCK(m_surface);
; 309  : 
; 310  : 	if (surface_width - offset_x < 0 || surface_height - offset_y < 0)

	mov	eax, DWORD PTR _surface_width$[ebp]
	sub	eax, DWORD PTR _offset_x$[ebp]
	js	SHORT $LN5@screen_dat
	mov	eax, DWORD PTR _surface_height$[ebp]
	sub	eax, DWORD PTR _offset_y$[ebp]
	jns	SHORT $LN4@screen_dat
$LN5@screen_dat:

; 311  : 	{
; 312  : 		printf("%s \n", "ERROR: screen data invalid surface and offset params.");

	push	OFFSET ??_C@_0DG@MBLAMNOJ@ERROR?3?5screen?5data?5invalid?5surf@
	push	OFFSET ??_C@_04ILNEAJIO@?$CFs?5?6@
	call	_printf
	add	esp, 8

; 313  : 		ret_val |= -1;

	mov	DWORD PTR _ret_val$[ebp], -1
$LN4@screen_dat:

; 314  : 	}
; 315  : 
; 316  : 	m_texture_coord_in_surface.x = offset_x;

	mov	eax, DWORD PTR _offset_x$[ebp]
	mov	DWORD PTR _m_texture_coord_in_surface, eax

; 317  : 	m_texture_coord_in_surface.y = offset_y;

	mov	eax, DWORD PTR _offset_y$[ebp]
	mov	DWORD PTR _m_texture_coord_in_surface+4, eax

; 318  : 	m_texture_coord_in_surface.w = img_width;

	mov	eax, DWORD PTR _img_width$[ebp]
	mov	DWORD PTR _m_texture_coord_in_surface+8, eax

; 319  : 	m_texture_coord_in_surface.h = img_height;

	mov	eax, DWORD PTR _img_height$[ebp]
	mov	DWORD PTR _m_texture_coord_in_surface+12, eax

; 320  : 
; 321  : 
; 322  : 	//SDL_RenderClear(m_renderer);
; 323  : 
; 324  : 	//SDL_LockSurface(m_surface);
; 325  : 	//SDL_UnlockSurface(m_surface);
; 326  : 	//m_texture = SDL_CreateTextureFromSurface(m_renderer, m_surface);
; 327  : 	//ret_val |= SDL_CreateTextureFromSurface(m_renderer, m_surface);
; 328  : 
; 329  : 	SDL_RenderCopy(m_renderer, m_texture, NULL, NULL);

	push	0
	push	0
	mov	eax, DWORD PTR _m_texture
	push	eax
	mov	ecx, DWORD PTR _m_renderer
	push	ecx
	call	_SDL_RenderCopy
	add	esp, 16					; 00000010H

; 330  : 	SDL_RenderPresent(m_renderer);

	mov	eax, DWORD PTR _m_renderer
	push	eax
	call	_SDL_RenderPresent
	add	esp, 4

; 331  : 
; 332  : 	return 0;

	xor	eax, eax
$LN6@screen_dat:

; 333  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_screen_data_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\UFOP\C_Sources\window.c
;	COMDAT _set_palette
_TEXT	SEGMENT
_i$1 = -60						; size = 4
_n$ = -48						; size = 4
_ret_val$ = -36						; size = 4
_p$ = -24						; size = 4
_color$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_set_palette PROC					; COMDAT

; 100  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-64]
	mov	ecx, 16					; 00000010H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __86C92C55_window@c
	call	@__CheckForDebuggerJustMyCode@4

; 101  : 	SDL_Color color;
; 102  : 	SDL_Palette* p = m_surface->format->palette;

	mov	eax, DWORD PTR _m_surface
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _p$[ebp], edx

; 103  : 	int ret_val = 0;

	mov	DWORD PTR _ret_val$[ebp], 0

; 104  : 
; 105  : 	int n = 0;

	mov	DWORD PTR _n$[ebp], 0

; 106  : 	for (int i = 0; i < 256; i++)

	mov	DWORD PTR _i$1[ebp], 0
	jmp	SHORT $LN4@set_palett
$LN2@set_palett:
	mov	eax, DWORD PTR _i$1[ebp]
	add	eax, 1
	mov	DWORD PTR _i$1[ebp], eax
$LN4@set_palett:
	cmp	DWORD PTR _i$1[ebp], 256		; 00000100H
	jge	$LN3@set_palett

; 107  : 	{
; 108  : 		color.r = (current_pal[n * 3] << 2 | (current_pal[n * 3] >> 4 & 0x3));

	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _current_pal
	movzx	edx, BYTE PTR [ecx+eax]
	shl	edx, 2
	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _current_pal
	movzx	eax, BYTE PTR [ecx+eax]
	sar	eax, 4
	and	eax, 3
	or	edx, eax
	mov	BYTE PTR _color$[ebp], dl

; 109  : 		color.g = (current_pal[n * 3 + 1] << 2 | (current_pal[n * 3 + 1] >> 4 & 0x3));

	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _current_pal
	movzx	edx, BYTE PTR [ecx+eax+1]
	shl	edx, 2
	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _current_pal
	movzx	eax, BYTE PTR [ecx+eax+1]
	sar	eax, 4
	and	eax, 3
	or	edx, eax
	mov	BYTE PTR _color$[ebp+1], dl

; 110  : 		color.b = (current_pal[n * 3 + 2] << 2 | (current_pal[n * 3 + 2] >> 4 & 0x3));

	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _current_pal
	movzx	edx, BYTE PTR [ecx+eax+2]
	shl	edx, 2
	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _current_pal
	movzx	eax, BYTE PTR [ecx+eax+2]
	sar	eax, 4
	and	eax, 3
	or	edx, eax
	mov	BYTE PTR _color$[ebp+2], dl

; 111  : 		color.a = 0;

	mov	BYTE PTR _color$[ebp+3], 0

; 112  : 		n++;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 113  : 		ret_val |= SDL_SetPaletteColors(p, &color, i, 1);

	push	1
	mov	eax, DWORD PTR _i$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _color$[ebp]
	push	ecx
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_SDL_SetPaletteColors
	add	esp, 16					; 00000010H
	or	eax, DWORD PTR _ret_val$[ebp]
	mov	DWORD PTR _ret_val$[ebp], eax

; 114  : 		//printf ("r= %d,g= %d,b= %d\n", pal_ptr[n * 3], pal_ptr[n * 3 + 1], pal_ptr[n * 3 + 2]);
; 115  : 		//printf("r1= %d,r2= %d\n", (pal_ptr[n * 3] << 2 | (pal_ptr[n * 3] >> 4 & 0x3)), 4*pal_ptr[n * 3]);
; 116  : 		//SDL_SetPalette(result, SDL_LOGPAL, colors, 0, 256);
; 117  : 	}

	jmp	$LN2@set_palett
$LN3@set_palett:

; 118  : 	ret_val |= SDL_SetSurfacePalette(m_surface, p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _m_surface
	push	ecx
	call	_SDL_SetSurfacePalette
	add	esp, 8
	or	eax, DWORD PTR _ret_val$[ebp]
	mov	DWORD PTR _ret_val$[ebp], eax

; 119  : 	//SDL_SaveBMP(m_surface, "12345.bmp");
; 120  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@set_palett
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN8@set_palett:
	DD	1
	DD	$LN7@set_palett
$LN7@set_palett:
	DD	-12					; fffffff4H
	DD	4
	DD	$LN6@set_palett
$LN6@set_palett:
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	108					; 0000006cH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	0
_set_palette ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\UFOP\C_Sources\window.c
;	COMDAT _close_video
_TEXT	SEGMENT
_close_video PROC					; COMDAT

; 338  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __86C92C55_window@c
	call	@__CheckForDebuggerJustMyCode@4

; 339  : 	SDL_DestroyRenderer(m_renderer);

	mov	eax, DWORD PTR _m_renderer
	push	eax
	call	_SDL_DestroyRenderer
	add	esp, 4

; 340  : 	SDL_DestroyWindow(m_window);

	mov	eax, DWORD PTR _m_window
	push	eax
	call	_SDL_DestroyWindow
	add	esp, 4

; 341  : 	SDL_VideoQuit();

	call	_SDL_VideoQuit

; 342  : 	SDL_Quit();

	call	_SDL_Quit

; 343  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_close_video ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\UFOP\C_Sources\window.c
;	COMDAT _out_to_screen_2
_TEXT	SEGMENT
_m_texture_coord_in_surface$ = -20			; size = 16
_out_to_screen_2 PROC					; COMDAT

; 70   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __86C92C55_window@c
	call	@__CheckForDebuggerJustMyCode@4

; 71   : 	SDL_Rect m_texture_coord_in_surface;
; 72   : 
; 73   : 	m_texture_coord_in_surface.x = screenx;

	movzx	eax, WORD PTR _screenx
	mov	DWORD PTR _m_texture_coord_in_surface$[ebp], eax

; 74   : 	m_texture_coord_in_surface.y = screeny;

	movzx	eax, WORD PTR _screeny
	mov	DWORD PTR _m_texture_coord_in_surface$[ebp+4], eax

; 75   : 	m_texture_coord_in_surface.w = screenx - screenx_1;

	movzx	eax, WORD PTR _screenx
	movzx	ecx, WORD PTR _screenx_1
	sub	eax, ecx
	mov	DWORD PTR _m_texture_coord_in_surface$[ebp+8], eax

; 76   : 	m_texture_coord_in_surface.h = screeny - screeny_1;

	movzx	eax, WORD PTR _screeny
	movzx	ecx, WORD PTR _screeny_1
	sub	eax, ecx
	mov	DWORD PTR _m_texture_coord_in_surface$[ebp+12], eax

; 77   : 
; 78   : 	//printf("screenx_1= %d,screenx= %d,screeny= %d\n", screenx_1, screenx, screeny);
; 79   : 	if (screenx_1 < screenx && screeny_1 < screeny)

	movzx	eax, WORD PTR _screenx_1
	movzx	ecx, WORD PTR _screenx
	cmp	eax, ecx
	jge	$LN1@out_to_scr
	movzx	eax, WORD PTR _screeny_1
	movzx	ecx, WORD PTR _screeny
	cmp	eax, ecx
	jge	$LN1@out_to_scr

; 80   : 	{
; 81   : 		m_texture_coord_in_surface.x = screenx;

	movzx	eax, WORD PTR _screenx
	mov	DWORD PTR _m_texture_coord_in_surface$[ebp], eax

; 82   : 		m_texture_coord_in_surface.y = screeny;

	movzx	eax, WORD PTR _screeny
	mov	DWORD PTR _m_texture_coord_in_surface$[ebp+4], eax

; 83   : 		m_texture_coord_in_surface.w = screenx - screenx_1;

	movzx	eax, WORD PTR _screenx
	movzx	ecx, WORD PTR _screenx_1
	sub	eax, ecx
	mov	DWORD PTR _m_texture_coord_in_surface$[ebp+8], eax

; 84   : 		m_texture_coord_in_surface.h = screeny - screeny_1;

	movzx	eax, WORD PTR _screeny
	movzx	ecx, WORD PTR _screeny_1
	sub	eax, ecx
	mov	DWORD PTR _m_texture_coord_in_surface$[ebp+12], eax

; 85   : 
; 86   : 
; 87   : 		//SDL_RenderClear(m_renderer);
; 88   : 		m_surface = SDL_CreateRGBSurfaceFrom(temp_screen_buffer, 640, 480, 8, 640, 0, 0, 0, 0);

	push	0
	push	0
	push	0
	push	0
	push	640					; 00000280H
	push	8
	push	480					; 000001e0H
	push	640					; 00000280H
	mov	eax, DWORD PTR _temp_screen_buffer
	push	eax
	call	_SDL_CreateRGBSurfaceFrom
	add	esp, 36					; 00000024H
	mov	DWORD PTR _m_surface, eax

; 89   : 		set_palette();

	call	_set_palette

; 90   : 		screen_texture = SDL_CreateTextureFromSurface(m_renderer, m_surface);

	mov	eax, DWORD PTR _m_surface
	push	eax
	mov	ecx, DWORD PTR _m_renderer
	push	ecx
	call	_SDL_CreateTextureFromSurface
	add	esp, 8
	mov	DWORD PTR _screen_texture, eax

; 91   : 		SDL_RenderCopy(m_renderer, screen_texture, NULL, NULL);

	push	0
	push	0
	mov	eax, DWORD PTR _screen_texture
	push	eax
	mov	ecx, DWORD PTR _m_renderer
	push	ecx
	call	_SDL_RenderCopy
	add	esp, 16					; 00000010H

; 92   : 		//SDL_RenderCopy(m_renderer, screen_texture, NULL, &m_texture_coord_in_surface);
; 93   : 		SDL_RenderPresent(m_renderer);

	mov	eax, DWORD PTR _m_renderer
	push	eax
	call	_SDL_RenderPresent
	add	esp, 4

; 94   : 		SDL_Delay(50);

	push	50					; 00000032H
	call	_SDL_Delay
	add	esp, 4
$LN1@out_to_scr:

; 95   : 	}
; 96   : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@out_to_scr
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN6@out_to_scr:
	DD	1
	DD	$LN5@out_to_scr
$LN5@out_to_scr:
	DD	-20					; ffffffecH
	DD	16					; 00000010H
	DD	$LN4@out_to_scr
$LN4@out_to_scr:
	DB	109					; 0000006dH
	DB	95					; 0000005fH
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	120					; 00000078H
	DB	116					; 00000074H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	101					; 00000065H
	DB	95					; 0000005fH
	DB	99					; 00000063H
	DB	111					; 0000006fH
	DB	111					; 0000006fH
	DB	114					; 00000072H
	DB	100					; 00000064H
	DB	95					; 0000005fH
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	95					; 0000005fH
	DB	115					; 00000073H
	DB	117					; 00000075H
	DB	114					; 00000072H
	DB	102					; 00000066H
	DB	97					; 00000061H
	DB	99					; 00000063H
	DB	101					; 00000065H
	DB	0
_out_to_screen_2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\UFOP\C_Sources\window.c
;	COMDAT _out_to_screen
_TEXT	SEGMENT
_out_to_screen PROC					; COMDAT

; 36   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __86C92C55_window@c
	call	@__CheckForDebuggerJustMyCode@4

; 37   : 	SDL_RenderClear(m_renderer);

	mov	eax, DWORD PTR _m_renderer
	push	eax
	call	_SDL_RenderClear
	add	esp, 4

; 38   : 	m_surface = SDL_CreateRGBSurfaceFrom(temp_screen_buffer, 640, 480, 8, 640, 0, 0, 0, 0);

	push	0
	push	0
	push	0
	push	0
	push	640					; 00000280H
	push	8
	push	480					; 000001e0H
	push	640					; 00000280H
	mov	eax, DWORD PTR _temp_screen_buffer
	push	eax
	call	_SDL_CreateRGBSurfaceFrom
	add	esp, 36					; 00000024H
	mov	DWORD PTR _m_surface, eax

; 39   : 	set_palette();

	call	_set_palette

; 40   : 	screen_texture = SDL_CreateTextureFromSurface(m_renderer, m_surface);

	mov	eax, DWORD PTR _m_surface
	push	eax
	mov	ecx, DWORD PTR _m_renderer
	push	ecx
	call	_SDL_CreateTextureFromSurface
	add	esp, 8
	mov	DWORD PTR _screen_texture, eax

; 41   : 	//SDL_SaveBMP(m_surface, "123456.bmp");
; 42   : 
; 43   : 
; 44   : 	//SDL_RenderClear(m_renderer);
; 45   : 	SDL_RenderCopy(m_renderer, screen_texture, NULL, NULL);

	push	0
	push	0
	mov	eax, DWORD PTR _screen_texture
	push	eax
	mov	ecx, DWORD PTR _m_renderer
	push	ecx
	call	_SDL_RenderCopy
	add	esp, 16					; 00000010H

; 46   : 	SDL_RenderPresent(m_renderer);

	mov	eax, DWORD PTR _m_renderer
	push	eax
	call	_SDL_RenderPresent
	add	esp, 4

; 47   : 	SDL_Delay(50);

	push	50					; 00000032H
	call	_SDL_Delay
	add	esp, 4

; 48   : 	//SDL_SaveBMP(m_surface, "123456.bmp");
; 49   : 
; 50   : 	//screen_data_init((uint8_t*)isobord1_dat, 640, 480, 640, 128, 0, 400);
; 51   : 
; 52   : 	/*
; 53   : 	SDL_Event event;
; 54   : 	while (1)
; 55   : 	{
; 56   : 		if (SDL_PollEvent(&event))
; 57   : 		{
; 58   : 			if (event.type == SDL_MOUSEBUTTONDOWN)
; 59   : 			{
; 60   : 				break;
; 61   : 			}
; 62   : 		}
; 63   : 	}
; 64   : */
; 65   : //SDL_DestroyWindow(m_window);
; 66   : //SDL_Quit();
; 67   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_out_to_screen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\UFOP\C_Sources\window.c
;	COMDAT _palette_mix
_TEXT	SEGMENT
_n$ = -92						; size = 4
_index$ = -80						; size = 4
_b2$ = -65						; size = 1
_b1$ = -53						; size = 1
_g2$ = -41						; size = 1
_g1$ = -29						; size = 1
_r2$ = -17						; size = 1
_r1$ = -5						; size = 1
_mix_index$ = 8						; size = 4
_pal_1$ = 12						; size = 4
_pal_2$ = 16						; size = 4
_palette_mix PROC					; COMDAT

; 131  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-96]
	mov	ecx, 24					; 00000018H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __86C92C55_window@c
	call	@__CheckForDebuggerJustMyCode@4

; 132  : 	uint8_t r1, r2, g1, g2, b1, b2;
; 133  : 	uint32_t index = 16;

	mov	DWORD PTR _index$[ebp], 16		; 00000010H

; 134  : 	int n = 0;

	mov	DWORD PTR _n$[ebp], 0

; 135  : 	pal_1 += 48;

	mov	eax, DWORD PTR _pal_1$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR _pal_1$[ebp], eax

; 136  : 	pal_2 += 48;

	mov	eax, DWORD PTR _pal_2$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR _pal_2$[ebp], eax
$LN4@palette_mi:

; 137  : 	do
; 138  : 	{
; 139  : 		r1 = pal_1[n * 3];

	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _pal_1$[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _r1$[ebp], dl

; 140  : 		r2 = pal_2[n * 3];

	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _pal_2$[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _r2$[ebp], dl

; 141  : 
; 142  : 		g1 = pal_1[n * 3 + 1];

	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _pal_1$[ebp]
	mov	dl, BYTE PTR [ecx+eax+1]
	mov	BYTE PTR _g1$[ebp], dl

; 143  : 		g2 = pal_2[n * 3 + 1];

	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _pal_2$[ebp]
	mov	dl, BYTE PTR [ecx+eax+1]
	mov	BYTE PTR _g2$[ebp], dl

; 144  : 
; 145  : 		b1 = pal_1[n * 3 + 2];

	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _pal_1$[ebp]
	mov	dl, BYTE PTR [ecx+eax+2]
	mov	BYTE PTR _b1$[ebp], dl

; 146  : 		b2 = pal_2[n * 3 + 2];

	imul	eax, DWORD PTR _n$[ebp], 3
	mov	ecx, DWORD PTR _pal_2$[ebp]
	mov	dl, BYTE PTR [ecx+eax+2]
	mov	BYTE PTR _b2$[ebp], dl

; 147  : 
; 148  : 		current_pal[index * 3] = r2 + ((mix_index * (r1 - r2)) >> 5);

	movzx	eax, BYTE PTR _r2$[ebp]
	movzx	ecx, BYTE PTR _r1$[ebp]
	movzx	edx, BYTE PTR _r2$[ebp]
	sub	ecx, edx
	imul	ecx, DWORD PTR _mix_index$[ebp]
	shr	ecx, 5
	add	eax, ecx
	imul	ecx, DWORD PTR _index$[ebp], 3
	mov	edx, DWORD PTR _current_pal
	mov	BYTE PTR [edx+ecx], al

; 149  : 		current_pal[index * 3 + 1] = g2 + ((mix_index * (g1 - g2)) >> 5);

	movzx	eax, BYTE PTR _g2$[ebp]
	movzx	ecx, BYTE PTR _g1$[ebp]
	movzx	edx, BYTE PTR _g2$[ebp]
	sub	ecx, edx
	imul	ecx, DWORD PTR _mix_index$[ebp]
	shr	ecx, 5
	add	eax, ecx
	imul	ecx, DWORD PTR _index$[ebp], 3
	mov	edx, DWORD PTR _current_pal
	mov	BYTE PTR [edx+ecx+1], al

; 150  : 		current_pal[index * 3 + 2] = b2 + ((mix_index * (b1 - b2)) >> 5);

	movzx	eax, BYTE PTR _b2$[ebp]
	movzx	ecx, BYTE PTR _b1$[ebp]
	movzx	edx, BYTE PTR _b2$[ebp]
	sub	ecx, edx
	imul	ecx, DWORD PTR _mix_index$[ebp]
	shr	ecx, 5
	add	eax, ecx
	imul	ecx, DWORD PTR _index$[ebp], 3
	mov	edx, DWORD PTR _current_pal
	mov	BYTE PTR [edx+ecx+2], al

; 151  : 		set_palette();

	call	_set_palette

; 152  : 		//printf("r1= %d,g1= %d,b1= %d\n", r1, g1 ,b1);
; 153  : 		++n;

	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 154  : 		index++;

	mov	eax, DWORD PTR _index$[ebp]
	add	eax, 1
	mov	DWORD PTR _index$[ebp], eax

; 155  : 	} while (index != 229);

	cmp	DWORD PTR _index$[ebp], 229		; 000000e5H
	jne	$LN4@palette_mi

; 156  : 
; 157  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 288				; 00000120H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_palette_mix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\UFOP\C_Sources\window.c
;	COMDAT _palette_correct
_TEXT	SEGMENT
_index$ = 8						; size = 4
_red$ = 12						; size = 4
_green$ = 16						; size = 4
_blue$ = 20						; size = 4
_palette_correct PROC					; COMDAT

; 123  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __86C92C55_window@c
	call	@__CheckForDebuggerJustMyCode@4

; 124  : 	current_pal[index * 3] = red;

	imul	eax, DWORD PTR _index$[ebp], 3
	mov	ecx, DWORD PTR _current_pal
	mov	dl, BYTE PTR _red$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 125  : 	current_pal[index * 3 + 1] = green;

	imul	eax, DWORD PTR _index$[ebp], 3
	mov	ecx, DWORD PTR _current_pal
	mov	dl, BYTE PTR _green$[ebp]
	mov	BYTE PTR [ecx+eax+1], dl

; 126  : 	current_pal[index * 3 + 2] = blue;

	imul	eax, DWORD PTR _index$[ebp], 3
	mov	ecx, DWORD PTR _current_pal
	mov	dl, BYTE PTR _blue$[ebp]
	mov	BYTE PTR [ecx+eax+2], dl

; 127  : 	set_palette();

	call	_set_palette

; 128  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_palette_correct ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\UFOP\C_Sources\window.c
;	COMDAT _screenshot
_TEXT	SEGMENT
_path$ = 8						; size = 4
_screenshot PROC					; COMDAT

; 165  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __86C92C55_window@c
	call	@__CheckForDebuggerJustMyCode@4

; 166  : 	SDL_SaveBMP(m_surface, path);

	push	1
	push	OFFSET ??_C@_02GMLFBBN@wb@
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	_SDL_RWFromFile
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR _m_surface
	push	ecx
	call	_SDL_SaveBMP_RW
	add	esp, 12					; 0000000cH

; 167  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_screenshot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\FreeApoc\Apocalypse\UFOP\C_Sources\window.c
;	COMDAT _video_init
_TEXT	SEGMENT
_monitor_height$1 = -64					; size = 4
_monitor_width$2 = -52					; size = 4
_DM$3 = -40						; size = 20
_ret_val$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_video_init PROC					; COMDAT

; 174  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-68]
	mov	ecx, 17					; 00000011H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	ecx, OFFSET __86C92C55_window@c
	call	@__CheckForDebuggerJustMyCode@4

; 175  : 	int ret_val = 0;

	mov	DWORD PTR _ret_val$[ebp], 0

; 176  : 	//int imgFlags = IMG_INIT_PNG;
; 177  : 	//IMG_Init(imgFlags);
; 178  : 
; 179  : 	if (SDL_Init(SDL_INIT_VIDEO))

	push	32					; 00000020H
	call	_SDL_Init
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@video_init

; 180  : 	{
; 181  : 		printf("%s %s \n", "ERROR: init SDL video. ", SDL_GetError());

	call	_SDL_GetError
	push	eax
	push	OFFSET ??_C@_0BI@KCEBAPDC@ERROR?3?5init?5SDL?5video?4?5@
	push	OFFSET ??_C@_07EDGOICEI@?$CFs?5?$CFs?5?6@
	call	_printf
	add	esp, 12					; 0000000cH

; 182  : 		ret_val |= 1;

	mov	eax, DWORD PTR _ret_val$[ebp]
	or	eax, 1
	mov	DWORD PTR _ret_val$[ebp], eax

; 183  : 		return ret_val;

	mov	eax, DWORD PTR _ret_val$[ebp]
	jmp	$LN1@video_init

; 184  : 
; 185  : 		SDL_DisplayMode DM;
; 186  : 		if (SDL_GetCurrentDisplayMode(0, &DM))

	lea	eax, DWORD PTR _DM$3[ebp]
	push	eax
	push	0
	call	_SDL_GetCurrentDisplayMode
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@video_init

; 187  : 		{
; 188  : 			printf("%s %s \n", "ERROR: get display mode. ", SDL_GetError());

	call	_SDL_GetError
	push	eax
	push	OFFSET ??_C@_0BK@GNKLFGAB@ERROR?3?5get?5display?5mode?4?5@
	push	OFFSET ??_C@_07EDGOICEI@?$CFs?5?$CFs?5?6@
	call	_printf
	add	esp, 12					; 0000000cH

; 189  : 			ret_val |= 1;

	mov	eax, DWORD PTR _ret_val$[ebp]
	or	eax, 1
	mov	DWORD PTR _ret_val$[ebp], eax
$LN3@video_init:

; 190  : 		}
; 191  : 		int monitor_width = DM.w;

	mov	eax, DWORD PTR _DM$3[ebp+4]
	mov	DWORD PTR _monitor_width$2[ebp], eax

; 192  : 		int monitor_height = DM.h;

	mov	eax, DWORD PTR _DM$3[ebp+8]
	mov	DWORD PTR _monitor_height$1[ebp], eax
$LN2@video_init:

; 193  : 	}
; 194  : 
; 195  : 	m_window = SDL_CreateWindow("Apocalypse",

	push	0
	push	480					; 000001e0H
	push	640					; 00000280H
	push	805240832				; 2fff0000H
	push	805240832				; 2fff0000H
	push	OFFSET ??_C@_0L@CLHOAHDA@Apocalypse@
	call	_SDL_CreateWindow
	add	esp, 24					; 00000018H
	mov	DWORD PTR _m_window, eax

; 196  : 		SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, 0);
; 197  : 
; 198  : 	if (!m_window)

	cmp	DWORD PTR _m_window, 0
	jne	SHORT $LN4@video_init

; 199  : 	{
; 200  : 		printf("%s %s \n", "ERROR: created window. ", SDL_GetError());

	call	_SDL_GetError
	push	eax
	push	OFFSET ??_C@_0BI@KAPODFJF@ERROR?3?5created?5window?4?5@
	push	OFFSET ??_C@_07EDGOICEI@?$CFs?5?$CFs?5?6@
	call	_printf
	add	esp, 12					; 0000000cH

; 201  : 		ret_val |= 1;

	mov	eax, DWORD PTR _ret_val$[ebp]
	or	eax, 1
	mov	DWORD PTR _ret_val$[ebp], eax

; 202  : 		return ret_val;

	mov	eax, DWORD PTR _ret_val$[ebp]
	jmp	SHORT $LN1@video_init
$LN4@video_init:

; 203  : 	}
; 204  : 
; 205  : 	m_renderer = SDL_CreateRenderer(m_window, -1, 0);

	push	0
	push	-1
	mov	eax, DWORD PTR _m_window
	push	eax
	call	_SDL_CreateRenderer
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _m_renderer, eax

; 206  : 	//SDL_RenderPresent(m_renderer);
; 207  : 	//PCX_Load("UFODATA\\TITLES.PCX");
; 208  : 	//SDL_RenderPresent(m_renderer);
; 209  : 
; 210  : 
; 211  : 	//SDL_Event event;
; 212  : 
; 213  : 	//while (1)
; 214  : 	//{
; 215  : 	  //  if (SDL_PollEvent(&event)) 
; 216  : 		//{ 
; 217  : 		//if (event.type == SDL_MOUSEBUTTONDOWN)
; 218  : 		//{
; 219  : 			//free_win();
; 220  : 			//SDL_Quit();
; 221  : 			//exit(0);
; 222  : 		//}
; 223  : 	//  }
; 224  : 	//}
; 225  : 
; 226  : 	//for (; events.type != SDL_QUIT && events.type != SDL_KEYDOWN; SDL_PollEvent(&events));
; 227  : 
; 228  : 	//SDL_DestroyWindow(m_window);
; 229  : 	//SDL_Quit();
; 230  : 
; 231  : 	return ret_val;

	mov	eax, DWORD PTR _ret_val$[ebp]
$LN1@video_init:

; 232  : }

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN8@video_init
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN8@video_init:
	DD	1
	DD	$LN7@video_init
$LN7@video_init:
	DD	-40					; ffffffd8H
	DD	20					; 00000014H
	DD	$LN6@video_init
$LN6@video_init:
	DB	68					; 00000044H
	DB	77					; 0000004dH
	DB	0
_video_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__ArgList$ = -20					; size = 4
__Result$ = -8						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-24]
	mov	ecx, 6
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	esi, esp
	push	1
	call	DWORD PTR __imp____acrt_iob_func
	add	esp, 4
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	eax
	call	__vfprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 963  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __6DFAE8B8_stdio@h
	call	@__CheckForDebuggerJustMyCode@4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	mov	esi, esp
	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Stream$[ebp]
	push	eax
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	DWORD PTR __imp____stdio_common_vfprintf
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp

; 646  :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	mov	edi, ebp
	xor	ecx, ecx
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET __A2143F22_corecrt_stdio_config@h
	call	@__CheckForDebuggerJustMyCode@4

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
